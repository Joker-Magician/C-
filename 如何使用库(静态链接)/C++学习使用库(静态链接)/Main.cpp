#include<iostream>//以下载的32位的GLFW库为例子
#include<GLFW/glfw3.h>//主要环境是32位,不然会报错
//只要在这个解决方案中(即使是其他项目)那么就用引用。如何它是一个完全的外部依赖或者外部的库，不在VS中和我一的实际解决方案一起编译就用<>

//extern "C" int glfwInit();这样会链接到一个在C语言建立的库


//下载是32位还是64位并不是取决于你的操作系统，而是你想要做的东西是是32位还是64位
//库通常包含两部分，includes和library,即目录(包含目录是一堆头文件)和库目录,include目录是一堆我们需要使用的头文件，可以我们就可以使用预构建的二进制文件中的函数
//然后lib目录有那些预构建的二进制文件，这里通常有动态库和静态库两部分(不是所有的库都提供这两种库)


int main()
{
	int a = glfwInit();
	std::cout << a << std::endl;

	std::cin.get();
}

//静态链接意味着这个吧库会被放到你的可执行文件中，它在你的exe文件中(或其他操作系统的可执行文件)
//动态链接是在运行时被链接的，所以你仍然有一些链接，你可以选择在程序运行时装载动态链接库，有一个叫做loadLibrary的函数，你可以在WindowsAPI中使用它作为例子
  //它会载入你的动态库，可以从中拉出函数，然后开始调用函数，你也可以在程序启动时加载你的dll文件。这就是动态链接库

//主要区别是库文件是否被编译到exe文件中或链接到exe文件中，还是只是一个单独的文件，在运行时你需要把它放在你的exe文件旁边或某个地方，然后你的exe文件可以加载它。
//这和静态链接是不同的东西，因为这种依赖性，你需要有exe文件和dll文件在一起
//通常静态链接在技术上更快，因为编译器或链接器实际上可以执行链接时优化之类的，因为我们知道链接时的链接库
//对于动态链接我们不知道会发生什么，我们必须保持它的完整，当动态链接库被运行时的程序装载时，程序的部分将被补充完整
//通常静态链接是更好的选择

//1.在这个解决方案目录下创建一个名为dependencies的文件夹，这就是管理依赖项，也就是库文件的目录
//2.在dependencies目录下，创建另一个GLFW的文件夹，然后将下载的GLFW32位文件夹中的include和lib-vc2022(目前最新的，更兼容vs2022)，复制到该GLFW文件夹下
	//.dll是一种动态库，动态链接时会用到，.lib是一种静态库，他与dll是一起用的，这样就不需要实际询问dll

//3.包含这个目录相对路径下的相关文件：右击该项目下属性->C/C++->常规->附加包含目录->$(SolutionDir)Dependencies\GLFW\include  ((SolutionDir表示相对引用))
//这时编译可以通过，但是运行build会出现链接错误（说没有找到实际的函数），没有链接到实际的库
//4.手动添加glfwInit的定义：1）右击该项目下属性->链接器->输入->在附加依赖项最前面添加glfw3.lib
//							2）链接器->常规->在附加库目录添加$(SolutionDir)Dependencies\GLFW\lib-vc2022