#include<iostream>

class Singleton//单例
{
public:
	static Singleton& Get()//对应第二步，我们需要某种静态函数，它会返回特定类型的引用或指针,通常叫他GetInstance或者简写成Get
	{ //然后需要返回某种Singleton的实例.现在，因为它只是一个i单例类，很明显，对于整个应用程序，这个类只有一个实例，所以你设计这个的方式，完全取决于你

	}
private:
	//首先，我们不能有构造函数，因为如果公共的构造函数，它就会被允许实例化,所以要将下面的这个构造函数标记为private,这意味着该类不能在外部被实例化
	Singleton() {}//第二步是提供一种静态访问该类的方法

	static Singleton s_Instance;//传统方法简单地创建那个单例类的静态实例，在这个私有成员里
};

int main()
{

	std::cin.get();
}

//单例模式，一种设计模式，单例是一个类的单一实例，你只打算有那个类或结构体的一个实例，类和结构体在C++中几乎是一样的。面向对象编程，总的来说拥有这些对象和类的好处在于，你可以多次实例化它们，而不是说，我写完我所有的代码，然后我们要实例化对象，但我不会实例化这个对象的多个实例，这就有点适得其反了，那我为社么还要一个对象呢？
//如果你在使用单例，很容易看出它不必须要一个类，一方面，如果你是有一个对象的单一实例，那么只会有单一数据集，然后可能有一些功能；但另一方面，我们有代表数据的类成员变量，我们有成员函数，代表的是对特定的数据集执行操作，或者以其他方式与数据交互 

//当我们想要拥有应用于某种全局数据集的功能，且我们只是像要重复使用时，单例时非常有用的。
//一个关于单例的基础案例，比如一个随机数生成器类，我们只希望能查询它，比如给我们一个随机数，我们不需要实例化它，遍历所有这些东西。不需要，因为我们只想实例化它一次，这样它就会生成随机数生成器的种子，建立起它所需要的任何辅助的东西了，然后我们要调用一个函数，基于我们初始化它的结果，它会给我们一个随机数，就这么简单
//另一个很好的例子时渲染器，渲染器通常是一个非常全局的东西，我们同常不会有一个渲染器的多个实例，我们有一个渲染器，我们会向它提交所有这些渲染命令，然后它为我们渲染一些东西，如果我们将其分解到opengl的部分，我们实际上通过渲染器调用opengl调用的东西本身就是一组全局函数，这根本不是个某种对象有关的东西，它们只是C风格的函数，没有类，一点关系都没有
//我们可能想要的是能够将类用作命名空间，类调用某些函数，这也是单例有点乱的地方

//从根本上说，单例的行为就像命名空间，单例类可以像命名空间一样工作，并没有要求说单例类要像普通类一样工作
//请记住，C++中的单例只是一种组织一堆全局变量和静态函数的方式，这些静态函数有时可能对这些变量起作用，有时也可能不对这些变量起作用，最后把这些组织在一起，本质上是在一个单一命名空间下。当然，它也可以灵活的绕开这些规则