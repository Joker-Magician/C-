#include<iostream>
#include<string>

void* operator new(size_t size)
{
	std::cout << "Allocating " << size << " bytes\n";
	return malloc(size);
}

int main()
{
	std::string name1 = "Cherno";//6个字符，符合小字符串的标准，这意味着它实际上只是存储在一个静态分配的缓冲区，根本不会触及堆内存
//可通过右击转到定义，查看_BUF_SIZE - 1为缓冲区的大小为15，_BUF_SIZE为16，这就构成了小字符串
//可通过重载的new，打印出8个字符

	std::string name2 = "Cherno Small St";//15个字符

	std::string name3 = "Cherno Small Str";
//以上小于15的打印操作均基于debug模式，在release模式下是没有堆分配的，一旦超过16个字符，我们就会在堆上分配内存

	std::cin.get();
}

//小字符串优化，简称sso
//我们不喜欢字符串的原因之一，是它们倾向于分配内存，C++是要追求快，而堆分配是慢的，这样不好，所以很多人会尽量避免，他们会尽量减少字符串的使用或者它们会想出如何使用字符串的创意
//但是在C++中有一些例外，小字符串，也就是不是很长的字符串，它们是不需要分配的，我可以只分配一小块基于栈的缓冲区而不是堆分配的，那将是我的静态字符串存储，对于小于一定长度的字符串(现在定义一个小字符串的实际长度，可以根据你所使用的C++标准库而变化，通常为15个字节)
//如果你有一个不超过15个字符的字符串，它不会在堆上分配内存，它只会使用栈缓冲区。但是，如果你有一个字符串，是16个字符或以上，那就会调用heap malloc或者heap alloc，不管是哪个在你的平台上分配内存了
//换句话说，如果你有一个非常小的字符串，你就不需要使用const char*,或者试图微观管理或优化你的代码，因为这很可能不会导致堆分配