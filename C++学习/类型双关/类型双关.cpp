#include<iostream>

struct Entity
{
	int x, y;

	int* GetPosition()
	{
		return &x;
	}
};

int main()
{
	int a = 50;
	double value = a;//这里a隐式转换成了double
	double value = (double)a;//显式转换
	std::cout << value << std::endl;

	int a1 = 50;
	double value = *(double*)&a1;//这里做的就是类型双关，从int到double
//&a取a的地址,所以我们得到了一个int指针,然后(double*)把它转换成double指针,最后我们要把它再转换成double类型，所以还需要*解引用
	std::cout << value << std::endl;//打印地址
//这里我们取了一个4字节的整数，然后定位成double，这会让后面四个bite没有初始化
	//这种情况很糟糕，在某些情况下甚至会导致崩溃
	
	int a2 = 50;
	double& value = *(double*)&a2;//只当成double来访问,引用而不是拷贝变成一个新的变量
	value = 0.0;
	std::cout << value << std::endl;


//在内存中，这个结构体其实就是有两个整数组成的.结构体本身不包含任何类型的填充，任何类型的数据。如果一个空的结构体那么它至少是一个字节，所以里面会有东西
//因为我们需要对这段内存进行寻址,而如果结构体包含两个整数，那结构体就只有这两个整数，没有其他东西.
	//因此我们可以将Entity结构体看成是一个int数组,而且不用通过e.x,e.y就可以提取出这些整数
	Entity e = { 5, 8 };//初始化为5和8

	/*position[2]是不行的，因为我们没有第三个元素，这样就跳出了范围*/

	int* position1 = (int*)&e;
	std::cout << position1[0] << "," << position1[1] << std::endl;
//本质上是先清楚了结构体的内存分布，然后使用指针进行了内存访问

	int y = *(int*)((char*)&e + 4);//&e得到e的地址，然后将其转换成char*,又char只是一个字节的大小，所以需要+4向前移动四个字节,然后转换成int指针，再解引用
	std::cout << y << std::endl;
//这里疯狂的操作重点是，我们回到了原始的内存操作,C++很善长搞这个，它是一种强大的语言的重要原因是，它可以很容易地自如地操纵内存

	int* position = e.GetPosition();
	position[0] = 2;
	//这样就改变了Entity的x坐标,这里没有冗余的复制(return &x)，我只是链接到了相同的内存,选择了一种不同的方式来解释内存

	std::cin.get();
}

//类型双关只是一个花哨的术语，用来在C++中绕过类型系统
//C++是强类型语言，也就是说我们有一个类型系统,我们不是所有东西都用auto去声明(C++中可以用auto，毕竟它也是一个关键字),但在其他语言中，比如javascript就没有变量类型的概念
//在C++中虽然类型是由编译器强制执行的，但我们可以直接访问内存,如我们可以一直使用的整形，但实际上可以把同样的内存当作double类型或class类型等,你可以很容易地绕过类型系统

//假设我们有一个类，我们想把它写成一个字节流,不需要很麻烦，假设他是一个基本类型的结果，并且没有指向内存中其他地方的指针，那么我们就可以重新解释整个结构或类等等,将它作为以哦个字节数组，然后将它写出来或者流出来(字节流),
//我们甚至不需要关注里面是什么类型，让我知道数据访问的大小，然后把它放到某个地方


//如果不想用原始类型转换,也可以使用reinterpret_cast做同样的事情

//类型双关，就是我要把我拥有的这段内存，当作不同的内存来对待,我们可以很自由的来做这件事，我们需要做的只是将该类型作为指针，然后将其转换为另一个指针,如果有必要就进行解引用应用