#include<iostream>
#include<string>

int GetValue()
{
	return 10;
}

int& GetValue1()//int&这个叫左值引用
{
	static int value = 10;//这样我们就需要为我的值提供某种存储空间，比如使用一个静态int,然后返回它
	return value;
}//这种情况，会因为这返回的是一个左值引用，所以可以给它赋值，下面的表达式也就没问题了，这就是左值引用

void SetValue(int value)
{
}

void SetValue1(int& value)
{
}

void SetValue2(const int& value)
{
}

int main()
{
	//简单定义
/*左值绝大多数时候在等号左边，右值在右边
请注意，这并不总是适用的，所以这不是一个完整的事实，不能总是这样认为，因为它不一定是对的*/
	
	int i1 = 10;//可以将10赋值给左值i,但你不能给一个右值赋值
	/*10 = i;这样是不被允许的，因为10没有位置，我们不能在10中存储数据*/
	int a1 = i1;//i是一个左值，显然我们可以用另一个变量a让它等于i。在这个例子中，我们设置一个左值等于一个同样是左值的值（这就是为什么等号右边是右值的说法是不对的）
	
	int i2 = GetValue();//等号的右边也可以等于一个函数。在这个例子中，GetValue返回右值，返回一个临时值；它是临时的，这是因为即使它返回一个int,它也没有位置，没有存储空间，它只返回值10
	int a2 = i2;
	/*GetValue() = 5;这样是不行的，我们的编译器会说，这个表达式必须是可修改的左值*/
	GetValue1() = 5;

	int i3 = 10;//调用SetValue可以使用左值，也可以使用右值
	SetValue(i3);//这里参数是左值
	SetValue(10);//而这种情况下，这里的参数是右值，当函数被调用时，这个右值会被用来创建一个左值
/*注意：你不能将右值赋给左值引用，所以左值引用的只能是左值*/

	//int& a = 10;/*这里的特殊规则是，虽然我不能用左值来引用右值，也就是不能这样*/
	const int& a = 10;//而这样是可以的。这是一种特殊规则，是一种变通手段，实际情况是，编译器可能会用你的存储创建一个临时变量，然后把它赋值给那个引用
	int temp = 10;
	const int& a3 = temp;//所以实际上它不可避免地创建了一个左值，但也同时支持了左值与右值

	int i4 = 10;
	SetValue1(i4);
	//SetValue1(10);这样是不可以的，编译器会说，非常量(const)引用的初始值必须是左值
	
	int i5 = 10;
	SetValue2(i5);
	SetValue2(10);//将其改为const引用后，这样它就同时可接受两种类型数据



	std::cin.get();
}

//很多人称左值为有地址的值(located value)