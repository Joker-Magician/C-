#include<iostream>

int main()
{
	//作为例子，二维数组实际上它只是数组的数组，而三维数组就是一个数组的数组的数组
	//即多维数组实际上是数组的集合
//我们考虑处理数组的一种策略就是使用指针，我们有一个指针指向数组在内存中的开头位置。则如果一个指针的数组，最终你会得到一个内存块，里面包含的是连续的指针，每个指针都指向我内存中的某个数组，所以我们得到的是指向数组的指针的集合，也就是数组的数组

//请注意以下你并不是以任何方式创建实际的整数，你所做的只是在分配内存，而int[50]这些只是在设置分配的大小而已，你当然也可以用这些内存来存储浮点数等等。
// int、float、char等类型只是一种语法，设置类型是用来处理数据的
	int* array = new int[50];//使用了堆分配，一维数组，拥有指向这个内存块的指针int*

	int** a2d = new int* [50]; // 二维数组，这里有一个指针的指针，因为我在这里存储的是一个指针对象的缓冲区int*，这是一个指向指针集合的指针
	//注意我们这里有的是一个指向整形指针的指针，而不是指向整形的指针.我们存储的实际数组其实还没有被分配，我们在这里创建的东西实际只是分配了200个字节的内存
	//a2d[0] = nullptr;
	for (int i = -0; i < 50; i++)
		a2d[i] = new int[50];//遍历a2d每一个指针，让它们分别指向一个[50]的数组，这样就得到了一个数组的数组。这就得到了二维数组

	{
		int*** a3d = new int** [50];
		for (int i = 0; i < 50; i++)
		{
			a3d[i] = new int* [50];//这里就得到了50个二维数组
			for (int j = 0; j < 50; j++)
			{//这里增加了另一个索引，因为a3d是一个指向指针的指针的指针，a3d[i]是对指针的第一部分进行解引用，a3d[i][j]是对指针的第二部分进行解引用
				a3d[i][j] = new int[50];

				/*int** ptr = a3d[i];
				ptr[j] = new int[50];这种写法和上面的写法是一样的*/
			}
		}
		//画个图，三级指针指向N块二级指针，二级指针指向M块一级指针，一级指针指向一块内存区域
		a3d[0][0][0] = 0;//访问三维数组
	}

	a2d[0][0] = 0;//[0]				   [0]
	a2d[0][1] = 0;//[1]				   [0]
	a2d[0][2] = 0;//[2]是要访问的整数；[0]是指针的索引，而不是整数的索引
	
	//delete[][] a2d这样写是不行的，没有[][]运算符，只能是delete[]
	/*delete[] a2d;只会释放int** a2d = new int* [50]的内存，它只是数组，保存实际整型数组的指针；而a2d[i] = new int[50]中共有50*200字节的内存，也就是你的50个数组的数据
这会造成内存泄漏，因为我们无法访问到它们了，将不能够在后面delete它们，因为我们删除了保存这些指针的数组*/
	
	for (int i = 0; i < 50; i++)
		delete[] a2d[i];
	delete[] a2d;//正确做法



//关于前面这些处理多维数组，除了明显很难处理的问题之外，还有些其他看法，这样处理数组的数组，会造成内存碎片问题
	int** a2d_1 = new int* [5];
	for (int i = 0; i < 5; i++)//这里5个数组的每一个都是5个整数组成的数组，因此我们有25个整数，我们没有一个连续的内存缓冲区，在一行中保存这25个整数
		a2d_1[i] = new int[5];//实际上，我们已经创建了5个单独的缓冲区，每个缓冲区有5个整数，它们会被这样分配，除非你采取某种自定义分配或采用内存池分配，它们会被分配到内存中完全随机的位置，可能隔得很远或很近，没有办法保证一定很近
//因为这个问题，我们每次遍历数组时，每次遍历5个之后跳到数组的下一行，或者说是数组的其他维度，我们必须跳转到内存只能的另一个位置来读写数据，这会导致cache miss(缓存不命中),意味我们在浪费时间从RAW中获取数据，如果它们恰好是紧密的一起分配的，那么可能不会造成cache miss，但是不能指望一定会分配到一起，通常是不会分配在一起的
/*实际上，用这种方式遍历这25个整数要比我只匹配一个一维数组要慢得多，因为一维数组的话，内存分配都在一行。最重要的一点是当你在编程和优化时，你在处理内存问题时，你可以优化的最重要的事情之一就是优化你的内存访问，
所以如果你能将要访问的内存存储在一起，那么在你定位数据时，会有更多的cache hits(缓存命中),以及更少的cache miss,后面将会学习更多的关于CPU缓存的知识*/

	for (int y = 0; y < 5; y++)
	{
		for (int x = 0; x < 5; x++) 
		{
			a2d_1[x][y] = 2;
		}//这是一个二维的网格，可以很容易通过x,y来处理数组
	}//这里代码每次我们都要跳出for循环，跳到一个完全不同的内存地址

	for (int i = 0; i < 5; i++)
		delete[] a2d_1[i];
	delete[] a2d_1;

	int* array = new int[5 * 5];
	for (int i = 0; i < 5 * 5; i++)
	{
		array[i] = 2;
	}//这是一种遍历方法
	for (int y = 0; y < 5; y++)
	{
		for (int x = 0; x < 5; x++)
		{
			array[x + y * 5] = 2;//这里意思是，每次y增加1，我就向前跳5个元素,这就相当于你的数组网格向下跳一行
		} // 这是仿照前面的遍历方法，这里的5时维度
	}//这里访问的是我们内存中同一行的内存，显然要比前面的速度要快


	std::cin.get();
}

//数组就是内存块，处理内存的简单方法是使用指针
//建议尽量避免使用二维数组，有时它们很有意义，但大多数时候是没意义的
//如果要存储一个位图bitmap，所有像素都在一张图片里，你可以把图像想象成照片或纹理，这种二维的东西，比如像素就像一个二维数组，那么应把它存成一个2D数组吗？
//不要这样，把它存成一个一维数组即可，虽然你把它存成一个二维数组还是一维数组都行，但是一维数组在存储图像上，要好得多得多

